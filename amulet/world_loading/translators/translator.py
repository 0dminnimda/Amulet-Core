from __future__ import annotations

from typing import Tuple

import numpy
import PyMCTranslate

from ...api.block import BlockManager
from ...api.chunk import Chunk


class Translator:
    def __init__(self):
        self.translation_manager = PyMCTranslate.new_translation_manager()

    def to_universal(self, chunk: Chunk, palette: numpy.ndarray, callback) -> Chunk:
        """
        Translate a decoder-specific chunk into the universal format.

        :param chunk: The chunk to translate.
        :return: Chunk object in the universal format.
        """
        translator = self.translation_manager.get_sub_version(*self._translator_key())
        palette = self._translate_palette(palette)

        todo = []
        finished = BlockManager()
        paletteMappings = {}

        for i, block in enumerate(palette):
            universal, entity, extra = translator.to_universal(None, block)
            if entity:
                print(f"Warning: not sure what to do with entity for {block} yet.")
            if extra and callback:
                todo.append(i)
                continue
            paletteMappings[i] = finished.get_add_block(universal)

        blockMappings = {}
        for index in todo:
            for x, y, z in zip(*numpy.where(chunk._blocks == index)):

                def get_block_at(dx, dy, dz):
                    nonlocal x, y, z, palette, chunk
                    dx += x
                    dy += y
                    dz += z
                    cx = dx // 16
                    cz = dz // 16
                    if cx == 0 and cz == 0:
                        return palette[chunk._blocks[dx % 16, dy, dz % 16]]
                    chunk, palette = callback(cx, cz)
                    block = palette[chunk._blocks[dx % 16, dy, dz % 16]]
                    return translator.from_universal(None, block)[0]

                block = palette[chunk._blocks[x, y, z]]
                universal, entity, extra = translator.to_universal(
                    get_block_at, block, (0, 0, 0)
                )
                if entity:
                    print(f"Warning: not sure what to do with entity for {block} yet.")
                blockMappings[(x, y, z)] = finished.get_add_block(universal)

        for old, new in paletteMappings.items():
            chunk._blocks[chunk._blocks == old] = new
        for (x, y, z), new in blockMappings.items():
            chunk._blocks[x, y, z] = new
        return chunk, finished

    def _translator_key(self) -> Tuple[str, Tuple[int, int, int]]:
        """
        Return the version key for PyMCTranslate

        :return: The tuple version key for PyMCTranslate
        """
        raise NotImplementedError()

    def _translate_palette(self, palette: numpy.ndarray) -> numpy.ndarray:
        """
        Translate the palette into a list of block objects.

        :return: The palette converted to block objects.
        """
        return palette

    def from_universal(self, chunk: Chunk) -> Tuple[Chunk, numpy.ndarray]:
        """
        Translate a universal chunk into the decoder-specific format.

        :param chunk: The chunk to translate.
        :return: Chunk object in the decoder-specific format and palette.
        """
        raise NotImplementedError()

    @staticmethod
    def identify(key: Tuple) -> bool:
        """
        Returns whether this decoder is able to decode the chunk type with a given identifier key,
        generated by the decoder.

        :param key: The key who's decodability needs to be checked.
        :return: True if this decoder can decode the chunk type associated with the key, False otherwise.
        """
        raise NotImplementedError()
