from __future__ import annotations

import os
import numpy
from typing import Tuple, Any, Union

from amulet.api.chunk import Chunk
from amulet.world_interface.chunk import translators
from amulet.world_interface.loader import Loader

SUPPORTED_INTERFACE_VERSION = 0
SUPPORTED_META_VERSION = 0

INTERFACES_DIRECTORY = os.path.dirname(__file__)

loader = Loader(
    "interface",
    INTERFACES_DIRECTORY,
    SUPPORTED_META_VERSION,
    SUPPORTED_INTERFACE_VERSION,
)


class Interface:
    def decode(self, data: Any) -> Tuple[Chunk, numpy.ndarray]:
        """
        Create an amulet.api.chunk.Chunk object from raw data given by the format
        :param data: Raw chunk data provided by the format.
        :type data: Any
        :return: Chunk object in version-specific format, along with the palette for that chunk.
        :rtype: Chunk
        """
        raise NotImplementedError()

    def encode(
        self,
        chunk: Chunk,
        palette: numpy.ndarray,
        max_world_version: Tuple[str, Union[int, Tuple[int, int, int]]],
    ) -> Any:
        """
        Take a version-specific chunk and encode it to raw data for the format to store.
        :param chunk: The already translated version-specfic chunk to encode.
        :type chunk: Chunk
        :param palette: The palette the ids in the chunk correspond to.
        :type palette: numpy.ndarray[Block]
        :return: Raw data to be stored by the Format.
        :rtype: Any
        """
        raise NotImplementedError()

    def get_translator(
        self,
        max_world_version: Tuple[str, Union[int, Tuple[int, int, int]]],
        data: Any = None,
    ) -> Tuple[translators.Translator, Union[int, Tuple[int, int, int]]]:
        """
        Get the Translator class for the requested version.
        :param max_world_version: The game version the world was last opened in.
        :type max_world_version: Java: int (DataVersion)    Bedrock: Tuple[int, int, int, ...] (game version number)
        :param data: Optional data to get translator based on chunk version rather than world version
        :param data: Any
        :return: Tuple[Translator, version number for PyMCTranslate to use]
        :rtype: Tuple[translators.Translator, Union[int, Tuple[int, int, int]]]
        """
        raise NotImplementedError

    def _get_translator_info(
        self, data: Any
    ) -> Tuple[Any, Union[int, Tuple[int, int, int]]]:
        """
        Returns a key to use to get a Translator class and the version number for use with PyMCTranslate
        :param data: Data to get translator
        :param data: Any
        :return: Tuple[key for translators.loader.get, version number for PyMCTranslate to use]
        :rtype: Tuple[Any, Union[int, Tuple[int, int, int]]]
        """
        raise NotImplementedError()

    @staticmethod
    def is_valid(key: Tuple) -> bool:
        """
        Returns whether this Interface is able to interface with the chunk type with a given identifier key,
        generated by the format.

        :param key: The key who's decodability needs to be checked.
        :return: True if this interface can interface with the chunk version associated with the key, False otherwise.
        """
        raise NotImplementedError()


if __name__ == "__main__":
    import time

    print(loader.get_all())
    time.sleep(1)
    loader.reload()
    print(loader.get_all())
